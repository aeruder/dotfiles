#!/usr/bin/env perl

use feature ':5.14';
use strictures 2;
use Getopt::Long;
use Data::Dumper;
use MIME::Base64;

sub quote {
  my ($arg) = @_;
  if ($arg !~ /^[\/:a-zA-Z0-9_,=.-]+$/) {
    $arg =~ s/'/'\\''/g;
    $arg = "'".$arg."'";
  }
  $arg;
}

my ($help,$login,$verbose);
my $dir=".";
my $host="localhost";
my $shell="/bin/sh";
my $perl="perl";
my @env;

Getopt::Long::Configure qw(require_order bundling no_ignore_case_always no_auto_abbrev);
GetOptions(
  'help'    => \$help,
  'login'   => \$login,
  'verbose' => \$verbose,
  'dir=s'   => \$dir,
  'host=s'  => \$host,
  'shell=s' => \$shell,
  'perl=s'  => \$perl,
  'env=s'   => \@env,
);

# Escaping on ssh is a nightmare, just have a static command-line by
# uuencoding a perl script and sending it over
my @cmd=(qw(ssh -q -t), $host);
my @shell_cmd = ($perl, qw(-MData::Dumper -MMIME::Base64 -e));
push @shell_cmd, 'eval decode_base64($ARGV[0])';

my $login_shell = $shell;
$login_shell =~ s/.*\///;
$login_shell = "-".$login_shell;

my @remote_cmd = ($login ? $login_shell : $shell, "-c");
my @remote_shell_cmd = @ARGV;
push @remote_cmd, join(" ", map { quote($_) } @remote_shell_cmd);

my $prog = Data::Dumper->Dump([\@remote_cmd, $dir, { %ENV{@env} }], ['REMOTECMD', 'REMOTEDIR', 'REMOTEENV']);
my $script = "my (\$REMOTECMD, \$REMOTEDIR, \$REMOTEENV);\n";
$script .= $prog;
$script .= "\%ENV = ( \%ENV, \%\$REMOTEENV );";
$script .= "chdir(\$REMOTEDIR);\n";
$script .= "print STDERR Data::Dumper->Dump([\$REMOTECMD], [\"REMOTECMD\"]);\n" if $verbose;
$script .= "exec {'$shell'} \@\$REMOTECMD;";

push @shell_cmd, encode_base64($script,"");
push @cmd, map { quote($_) } @shell_cmd;

print STDERR sprintf("=== REMOTE SCRIPT START ===\n%s\n=== REMOTE SCRIPT END===\n", $script) if $verbose;
print STDERR Data::Dumper->Dump([\@cmd], ["LOCALCMD"]) if $verbose;
exec {$cmd[0]} @cmd;
