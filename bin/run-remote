#!/usr/bin/env perl

use feature ':5.14';
use warnings;
use strict;
use Getopt::Long;
use Data::Dumper;
use MIME::Base64;

sub quote {
  my ($arg) = @_;
  if ($arg !~ /^[\/:a-zA-Z0-9_,=.-]+$/) {
    $arg =~ s/'/'\\''/g;
    $arg = "'".$arg."'";
  }
  $arg;
}

my ($help,$login,$verbose);
my $dir=".";
my $host="localhost";
my $perl="perl";
my @env;

Getopt::Long::Configure qw(require_order bundling no_ignore_case_always no_auto_abbrev);
GetOptions(
  'help'    => \$help,
  'login'   => \$login,
  'verbose' => \$verbose,
  'dir=s'   => \$dir,
  'host=s'  => \$host,
  'perl=s'  => \$perl,
  'env=s'   => \@env,
);
exit(0) unless @ARGV;

my %result_env = map {
  my @ret;
  if (/^(.+)=(.*)$/) {
    @ret = ( $1 => $2 );
  } else {
    @ret = ( $_ => $ENV{$_} ) if exists $ENV{$_};
  }
  @ret;
} @env;

# Escaping on ssh is a nightmare, just have a static command-line by
# uuencoding a perl script and sending it over
my @cmd=(qw(ssh -q), $host);
push @cmd, "-t" if -t STDOUT && -t STDERR;
my @shell_cmd = ($perl, qw(-Mwarnings -Mstrict -MData::Dumper -MMIME::Base64 -e));
push @shell_cmd, 'eval decode_base64($ARGV[0]); warn $@ if $@';

my @remote_cmd = @ARGV;
my $prog = Data::Dumper->Dump([\@remote_cmd, $dir, \%result_env ], ['REMOTECMD', 'REMOTEDIR', 'REMOTEENV']);
my $script = "my (\$REMOTECMD, \$REMOTEDIR, \$REMOTEENV);\n";
$script .= $prog;
$script .= "\%ENV = ( \%ENV, \%\$REMOTEENV );\n";
$script .= "chdir(\$REMOTEDIR);\n";
$script .= "print STDERR Data::Dumper->Dump([\$REMOTECMD], [\"REMOTECMD\"]);\n" if $verbose;
$script .= "{ exec {\$REMOTECMD->[0]} \@\$REMOTECMD; };\n";
$script .= "exit(127);";

push @shell_cmd, encode_base64($script,"");
push @cmd, map { quote($_) } @shell_cmd;

print STDERR sprintf("=== REMOTE SCRIPT START ===\n%s\n=== REMOTE SCRIPT END===\n", $script) if $verbose;
print STDERR Data::Dumper->Dump([\@cmd], ["LOCALCMD"]) if $verbose;
exec {$cmd[0]} @cmd;
