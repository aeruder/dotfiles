" File mappings

filetype off
call pathogen#runtime_append_all_bundles()



""""""""""""""""""""""""
" Turn off fuf data file
let g:fuf_dataDir = ''

"""""
" Default notes directory
let g:notes_directories = [ '~/.notes' ]


""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
" Lots and lots of settings
""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""

set nocompatible
syntax on

""""""""""""""""""""""""
" Color scheme
if has ("gui_running")
    if !(has("gui_win32"))
        set guifont=Inconsolata\ 10
    endif
    colors jellybeans
else
    if $COLORTERM == "gnome-terminal" || $KONSOLE_PROFILE_NAME != ""
        set t_Co=256
    endif
    set background=dark
    colors jellybeans
endif

""""""""""""""""""""""""
" Use with :Usespaces <num> and we
" are configured with indentation of <num>
" using spaces.
com! -nargs=1 Usespaces
  \ setlocal tabstop=<args> |
  \ setlocal expandtab |
  \ setlocal shiftwidth=<args> |
  \ setlocal softtabstop=<args> |
  \ setlocal nocopyindent

""""""""""""""""""""""""
" Use with :Usetabs <num> and we are
" configured with indentation of <num> using
" tabs.
com! -nargs=1 Usetabs
  \ setlocal tabstop=<args> |
  \ setlocal noexpandtab |
  \ setlocal shiftwidth=<args> |
  \ setlocal softtabstop=<args> |
  \ setlocal copyindent

""""""""""""""""""""""""
" GNU indentation style is a mess
com! -nargs=0 Gnuindent
  \ setlocal tabstop=8 |
  \ setlocal shiftwidth=2 |
  \ setlocal softtabstop=2 |
  \ setlocal noexpandtab |
  \ setlocal nocopyindent

""""""""""""""""""""""""
" Our default indentation style
:Usespaces 4

""""""""""""""""""""""""
" If we use special characters, ensure we are doing so with
" utf-8
set encoding=utf-8

""""""""""""""""""""""""
" Line wrap settings
set nowrap
set textwidth=79
set formatoptions=qrn1
set colorcolumn=

""""""""""""""""""""""""
" Give us some context around the cursor when scrolling
set sidescroll=10 sidescrolloff=10
set scrolloff=4

""""""""""""""""""""""""
" Set how we indent new lines, autoindent seems most
" sane to me (except when filetype indent is available)
set nosmartindent
set nocindent
set autoindent
set shiftround
filetype plugin indent on

""""""""""""""""""""""""
" Set up our status bar with lots of good information
set showmode
set showcmd
set ruler

""""""""""""""""""""""""
" Make our backspace sane (we want to be able to backspace over everything)
set backspace=indent,eol,start

""""""""""""""""""""""""
" Tab completion in command mode
set wildmenu
set wildmode=list:longest

""""""""""""""""""""""""
" When beeping, do it visually not audibly (which half the time
" doesn't work anyway)
" set visualbell

""""""""""""""""""""""""
" Highlight the entire line we are on
set cursorline

""""""""""""""""""""""""
" 99% of the time we'll be working on a really fast tty, so
" this makes redraw more smooth.
set ttyfast

""""""""""""""""""""""""
" Always enable the status line for the window, even if there is just
" one window.
set laststatus=2

""""""""""""""""""""""""
" Display the line numbers relative to the current line
set relativenumber

""""""""""""""""""""""""
" Persistent undo even if we quit vim.  Store that information in ~/.undo
set undofile
set undodir=~/.undo

""""""""""""""""""""""""
" Search settings
" If we search for Abc, it is case-sensitive, abc is case-insensitive
set ignorecase
set smartcase
" Search as we type
set incsearch
" Highlight our searches
set hlsearch
" Wrap at the end
set nowrapscan

""""""""""""""""""""""""
" When we type a bracket, quickly jump to the matching bracket
set showmatch

""""""""""""""""""""""""
" CScope settings
set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
set cscopetag

""""""""""""""""""""""""
" Allow us to switch away from an unsaved buffer
set hidden

""""""""""""""""""""""""
" When we yank text into the unnamed register, automatically put
" it on the clipboard.
set clipboard+=unnamed

""""""""""""""""""""""""
" When doing folds, base it on the syntax
set foldmethod=syntax

""""""""""""""""""""""""
" When using vimdiff, ignore white-space changes
set diffopt=iwhite,filler

""""""""""""""""""""""""
" Show tabs, trailing spaces, etc..
set list listchars=tab:»·,trail:·,extends:>,precedes:<






""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
" Key bindings
""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""

" Change our leader key to , rather than \
let mapleader = ","

" Align comma'd lists like
"
" a, b, c, d
" foo, bar, blah, baz
"
" to this when selected and ran through this command:
"
" a,   b,   c,    d
" foo, bar, blah, baz
"
vnoremap <leader>A, :Tab /[;,]<CR>gv:s/\v(\s+)([,;])\s?/\2\1/g<CR>gv:s/\v\s+$//<CR>:let @/=""<CR>

" Helps debug making syntax files, displays the syntax of the
" character underneath the cursor.
nnoremap <leader>S :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
         \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
         \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" Clear the highlighted search
nnoremap <leader><space> :nohlsearch<CR>
nnoremap <leader>D :%s/<C-R>///g<CR>
nnoremap <leader>gD :%g/<C-R>//d<CR>
nnoremap <leader>g!D :%g!/<C-R>//d<CR>
vnoremap <leader>D :s/<C-R>///g<CR>
vnoremap <leader>gD :g/<C-R>//d<CR>
vnoremap <leader>g!D :g!/<C-R>//d<CR>

" Highlight spacing errors
nnoremap <leader>s /\v(\s+$)\|(<space>\ze<tab>)<CR>

" Highlight tabs
nnoremap <leader><Tab> /<Tab><CR>

" Highlight just pasted text
nnoremap <leader>v V`]

" Open vimrc
nnoremap <leader>ev <C-w>v<C-w>l:e $MYVIMRC<Cr>

" Open vertical split and switch to it
nnoremap <leader>w <C-w>v<C-w>l

" Make j and k go through wrapped lines
nnoremap j gj
nnoremap k gk

" Let us use ; instead of : for command mode
nnoremap ; :

" Use <tab> to bounce between matching parens
nnoremap <tab> %
vnoremap <tab> %

" Use 'jk' instead of ESC
inoremap jk <ESC>

" Toggle in and out of hex dump mode
nnoremap <leader>h :Hexmode<Cr>

" Open a scratch buffer
nnoremap <leader>es <C-w>v<C-w>l:Scratch<Cr>

" Open Fuzzyfinder
" nnoremap <leader>be :FufBuffer<Cr>

" Open NERDTree from directory where current file is
nnoremap <leader>bF :NERDTreeFind<Cr>

" Open NERDTree from current working directory
nnoremap <leader>bT :NERDTree<Cr>

" Open Ack
nnoremap <leader>a :Ack 

" Some plugin overrides
nmap <leader>Pswp <Plug>SaveWinPosn
nmap <leader>Prwp <Plug>RestoreWinPosn

" Unite
let g:unite_source_history_yank_enable = 1
call unite#filters#matcher_default#use(['matcher_fuzzy'])
nnoremap <leader>bf :<C-u>Unite -no-split -buffer-name=files   -start-insert file<cr>
nnoremap <leader>br :<C-u>Unite -no-split -buffer-name=mru     -start-insert file_mru<cr>
nnoremap <leader>bo :<C-u>Unite -no-split -buffer-name=outline -start-insert outline<cr>
nnoremap <leader>by :<C-u>Unite -no-split -buffer-name=yank    history/yank<cr>
nnoremap <leader>be :<C-u>Unite -no-split -buffer-name=buffer  -start-insert buffer<cr>

" Custom mappings for the unite buffer
autocmd FileType unite call s:unite_settings()
function! s:unite_settings()
  " Play nice with supertab
  let b:SuperTabDisabled=1
  setlocal ic
  " Enable navigation with control-j and control-k in insert mode
  imap <buffer> <C-j>   <Plug>(unite_select_next_line)
  imap <buffer> <C-k>   <Plug>(unite_select_previous_line)
endfunction


""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
" Our active abbreviations
""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
abbreviate teh the
abbreviate sl std_logic
abbreviate slv std_logic_vector


""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
" Misc custom commands, etc.
""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""

" This makes % work for a lot more than just
" {(<, it also works on html, etc..
runtime macros/matchit.vim

" This makes :Man open manpages in a split with syntax highlighting
runtime ftplugin/man.vim

" Set our ack path (which we store in our vim directory)
let s:ackexes = split(globpath(&rtp, 'bin/ack'), "\n")
if (len(s:ackexes) > 0)
    let g:ackprg="perl " . s:ackexes[0] . " -H --nocolor --nogroup --column"
endif

" Some filesystems that are mounted in /tmp (particularly on OS X), cause
" problems with backup files
autocmd BufRead /tmp/*
    \ setlocal nobackup |
    \ setlocal nowritebackup

" Some custom filetypes
au BufNewFile,BufRead build_log.txt     setf changelog
au BufNewFile,BufRead *.phys            setf cmphys
au BufNewFile,BufRead *.vb              set ft=vbnet
au BufNewFile,BufRead *.il              set ft=ilasm

" Space/tab settings for different filetypes
au FileType *
    \ Usespaces 4

au FileType python
    \ Usespaces 2

au FileType ruby
    \ Usespaces 2

au FileType make
    \ Usetabs 8

au FileType vhdl
    \ Usespaces 2

" This is used when editing a mutt mail message
comm! -nargs=0 BeginMailMessage call BeginMailMessage()
function! BeginMailMessage()
    set tw=72
    set wrap
    set expandtab
    set ft=mail
    silent! g/^Message-Id: <.*@.*>/d
    silent! %s/^My-\(Message-Id: <.*@.*>\)$/\1/
    normal 1G
endfunction

" Hex editing support (from http://vim.wikia.com/wiki/Improved_hex_editing)
comm! -bar Hexmode call ToggleHex()

" helper function to toggle hex mode
function! ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction

" Pull in our zsh special directories
function! PullInZshNamedDirectories()
    if (exists("$HOME"))
        let l:namedirs = $HOME . "/.znameddirs"
        if (filereadable(l:namedirs))
            let l:lines = readfile(l:namedirs)
            for l:a in l:lines
                let l:splitdir = split(l:a, " ")
                if (len(l:splitdir) == 2 && match(l:splitdir[0], '[^a-z0-9_A-Z]') == -1)
                    exec "let $" . l:splitdir[0] . " = '" . fnameescape(l:splitdir[1]) ."'"
                endif
            endfor
        endif
    endif
endfunction

call PullInZshNamedDirectories()
