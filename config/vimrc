" File mappings


runtime bundle/pathogen/autoload/pathogen.vim
if has('vim_starting')
    let config=pathogen#split(&runtimepath)[0]
    execute pathogen#infect()
    call dirsettings#Install()
endif

let &directory=expand("<sfile>:p:h:h")."/swp"
let &undodir=expand("<sfile>:p:h:h")."/undo"

""""""""""""""""""""""""
" Turn off fuf data file
let g:fuf_dataDir = ''

"""""
" Default notes directory
let g:notes_directories = [ '~/.notes' ]


""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
" Lots and lots of settings
""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""

set nocompatible
syntax on

""""""""""""""""""""""""
" Color scheme
if has ("gui_running")
    if !(has("gui_win32"))
        set guifont=Inconsolata\ 10
    endif
    colors jellybeans
elseif $TERM == "linux"
    set background=dark
    colors elflord
else
    if $COLORTERM == "gnome-terminal" || $KONSOLE_PROFILE_NAME != ""
        set t_Co=256
    endif
    set background=dark
    colors jellybeans
endif

""""""""""""""""""""""""
" Use with :Usespaces <num> and we
" are configured with indentation of <num>
" using spaces.
com! -nargs=1 Usespaces
            \ setlocal tabstop=<args> |
            \ setlocal expandtab |
            \ setlocal shiftwidth=<args> |
            \ setlocal softtabstop=<args> |
            \ setlocal nocopyindent

""""""""""""""""""""""""
" Use with :Usetabs <num> and we are
" configured with indentation of <num> using
" tabs.
com! -nargs=1 Usetabs
            \ setlocal tabstop=<args> |
            \ setlocal noexpandtab |
            \ setlocal shiftwidth=<args> |
            \ setlocal softtabstop=<args> |
            \ setlocal copyindent

""""""""""""""""""""""""
" GNU indentation style is a mess
com! -nargs=0 Gnuindent
            \ setlocal tabstop=8 |
            \ setlocal shiftwidth=2 |
            \ setlocal softtabstop=2 |
            \ setlocal noexpandtab |
            \ setlocal nocopyindent

""""""""""""""""""""""""
" Our default indentation style
set tabstop=4
set expandtab
set shiftwidth=4
set softtabstop=4
set nocopyindent

""""""""""""""""""""""""
" If we use special characters, ensure we are doing so with
" utf-8
set encoding=utf-8

""""""""""""""""""""""""
" Line wrap settings
set nowrap
set textwidth=79
set formatoptions=qrn1
set colorcolumn=

""""""""""""""""""""""""
" Default split directions
set splitbelow
set splitright

""""""""""""""""""""""""
" Give us some context around the cursor when scrolling
set sidescroll=10 sidescrolloff=10
set scrolloff=4

""""""""""""""""""""""""
" Set how we indent new lines, autoindent seems most
" sane to me (except when filetype indent is available)
set nosmartindent
set nocindent
set autoindent
set shiftround
filetype plugin indent on

""""""""""""""""""""""""
" Set up our status bar with lots of good information
set showmode
set showcmd
set ruler

""""""""""""""""""""""""
" Make our backspace sane (we want to be able to backspace over everything)
set backspace=indent,eol,start

""""""""""""""""""""""""
" Tab completion in command mode
set wildmenu
set wildmode=list:longest

""""""""""""""""""""""""
" When beeping, do it visually not audibly (which half the time
" doesn't work anyway)
set visualbell t_vb=

""""""""""""""""""""""""
" Highlight the entire line we are on
set cursorline

""""""""""""""""""""""""
" 99% of the time we'll be working on a really fast tty, so
" this makes redraw more smooth.
set ttyfast

""""""""""""""""""""""""
" Always enable the status line for the window, even if there is just
" one window.
set laststatus=2

""""""""""""""""""""""""
" Display the line numbers relative to the current line
set relativenumber

""""""""""""""""""""""""
" Persistent undo even if we quit vim.
set undofile

""""""""""""""""""""""""
" Search settings
" If we search for Abc, it is case-sensitive, abc is case-insensitive
set ignorecase
set smartcase
" Search as we type
set incsearch
" Highlight our searches
set hlsearch
" Wrap at the end
set nowrapscan

""""""""""""""""""""""""
" When we type a bracket, quickly jump to the matching bracket
set showmatch

""""""""""""""""""""""""
" CScope settings
set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
set cscopetag

""""""""""""""""""""""""
" Allow us to switch away from an unsaved buffer
set hidden

""""""""""""""""""""""""
" When we yank text into the unnamed register, automatically put
" it on the clipboard.
set clipboard+=unnamed

""""""""""""""""""""""""
" When doing folds, base it on the syntax
set foldmethod=syntax
set foldnestmax=2

""""""""""""""""""""""""
" When using vimdiff, ignore white-space changes
set diffopt=iwhite,filler

""""""""""""""""""""""""
" Show tabs, trailing spaces, etc..
set list listchars=tab:»·,trail:·,extends:>,precedes:<






""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
" Key bindings
""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""

" Change our leader key to , rather than \
let mapleader = ","
let g:EasyMotion_leader_key = '<Space>'

" Align comma'd lists like
"
" a, b, c, d
" foo, bar, blah, baz
"
" to this when selected and ran through this command:
"
" a,   b,   c,    d
" foo, bar, blah, baz
"
vnoremap <leader>A, :Tab /[;,]<CR>gv:s/\v(\s+)([,;])\s?/\2\1/g<CR>gv:s/\v\s+$//<CR>:let @/=""<CR>

" Helps debug making syntax files, displays the syntax of the
" character underneath the cursor.
nnoremap <leader>S :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
            \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
            \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" Clear the highlighted search
nnoremap <leader><space> :nohlsearch<CR>
nnoremap <leader>D :%s/<C-R>///g<CR>
nnoremap <leader>gD :%g/<C-R>//d<CR>
nnoremap <leader>g!D :%g!/<C-R>//d<CR>
vnoremap <leader>D :s/<C-R>///g<CR>
vnoremap <leader>gD :g/<C-R>//d<CR>
vnoremap <leader>g!D :g!/<C-R>//d<CR>

" Highlight spacing errors
nnoremap <leader>f<space> /\v(\s+$)\|(<space>\ze<tab>)<CR>

" Highlight tabs
nnoremap <leader>f<Tab> /<Tab><CR>

" Highlight just pasted text
nnoremap <leader>v V`]

" Open vimrc
nnoremap <leader>ev <C-w>v<C-w>l:e $MYVIMRC<Cr>

" Open vertical split and switch to it
nnoremap <leader>w <C-w>v<C-w>l

" Open undotree
nnoremap <leader>u :UndotreeToggle<Cr>

" Make j and k go through wrapped lines
nnoremap j gj
nnoremap k gk

" Let us use ; instead of : for command mode
nnoremap ; :

" Use 'jk' instead of ESC
inoremap jk <ESC>

" Toggle in and out of hex dump mode
nnoremap <leader>h :Hexmode<Cr>

" Open a scratch buffer
nnoremap <leader>es <C-w>v<C-w>l:Scratch<Cr>

" grep utilities
nnoremap <leader>fa yiw:Ag <C-R>"
nnoremap <leader>fg yiw:Ggrep <C-R>"
nnoremap <leader>fb yiw:Bgrep <C-R>"

" Some plugin overrides
nmap <leader>Pswp <Plug>SaveWinPosn
nmap <leader>Prwp <Plug>RestoreWinPosn

" Unite
let g:unite_enable_ignore_case = 0
let g:unite_enable_smart_case = 0
let g:unite_source_history_yank_enable = 1
let g:unite_source_rec_max_cache_files = 10000
let g:unite_source_file_mru_long_limit = 10000

call unite#filters#matcher_default#use(['matcher_glob'])
call unite#custom#source('buffer,file,file_mru,file_rec', 'sorters', 'sorter_length')
call unite#custom#source('file_mru', 'max_candidates', 10)
" call unite#custom#source('tag', 'matchers', 'matcher_exact')
" nnoremap <leader>bf :<C-u>Unite -no-split -buffer-name=files   -start-insert file<cr>
nnoremap <leader>bf :<C-u>execute "Unite -start-insert file" . (expand('%') == '' ? '' : ':' . expand('%:h'))   . ' file_rec/async:!'                                                    . ' file/new'<cr>
nnoremap <leader>bc :<C-u>execute "Unite -start-insert"                                                         . ' file_rec/async'   . (expand('%') == '' ? '' : ':' . expand('%:h'))   . ' file/new'<cr>
nnoremap <leader>bp :<C-u>execute "Unite -start-insert"                                                         . ' file_rec/async'   . (expand('%') == '' ? '' : ':' . expand('%:h:h')) . ' file/new'<cr>
nnoremap <leader>br :<C-u>Unite -start-insert file_mru<cr>
nnoremap <leader>bo :<C-u>Unite outline<cr>
nnoremap <leader>by :<C-u>Unite history/yank<cr>
nnoremap <leader>be :<C-u>Unite -start-insert buffer file_mru:all<cr>
nnoremap <leader>bb :<C-u>Unite -quick-match buffer<cr>

comm! -nargs=1 -complete=dir Go execute "Unite -start-insert file_rec/async:" . fnamemodify("<args>", ':p:~:.')

" Custom mappings for the unite buffer
autocmd FileType unite call s:unite_settings()
function! s:unite_settings()
  " Play nice with supertab
  let b:SuperTabDisabled=1
  " Enable navigation with control-j and control-k in insert mode
  imap <buffer> <C-j>   <Plug>(unite_select_next_line)
  imap <buffer> <C-k>   <Plug>(unite_select_previous_line)
endfunction

" Enable snippets
let g:neosnippet#enable_snipmate_compatibility = 1
let g:neosnippet#snippets_directory=config.'/snippets,'.config.'/bundle/vim-snippets/snippets'

imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif


""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
" Our active abbreviations
""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
abbreviate teh the
abbreviate sl std_logic
abbreviate slv std_logic_vector


""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""
" Misc custom commands, etc.
""""""""""""""""""""""""
""""""""""""""""""""""""
""""""""""""""""""""""""

" This makes % work for a lot more than just
" {(<, it also works on html, etc..
runtime macros/matchit.vim

" This makes :Man open manpages in a split with syntax highlighting
runtime ftplugin/man.vim

" Set our ack path (which we store in our vim directory)
let s:ackexes = split(globpath(&rtp, 'bin/ack'), "\n")
if (len(s:ackexes) > 0)
    let g:ackprg="perl " . s:ackexes[0] . " -H --nocolor --nogroup --column"
endif

" Some filesystems that are mounted in /tmp (particularly on OS X), cause
" problems with backup files
autocmd BufRead /tmp/*
    \ setlocal nobackup |
    \ setlocal nowritebackup

" Some custom filetypes
au BufNewFile,BufRead build_log.txt     setf changelog
au BufNewFile,BufRead *.phys            setf cmphys
au BufNewFile,BufRead *.vb              set ft=vbnet
au BufNewFile,BufRead *.il              set ft=ilasm

" Space/tab settings for different filetypes
au FileType make
    \ Usetabs 8

" This is used when editing a mutt mail message
comm! -nargs=0 BeginMailMessage call BeginMailMessage()
function! BeginMailMessage()
    set tw=72
    set wrap
    set expandtab
    set ft=mail
    silent! g/^Message-Id: <.*@.*>/d
    silent! %s/^My-\(Message-Id: <.*@.*>\)$/\1/
    normal 1G
endfunction

" Hex editing support (from http://vim.wikia.com/wiki/Improved_hex_editing)
comm! -bar Hexmode call ToggleHex()

" helper function to toggle hex mode
function! ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction

" Pull in our zsh special directories
function! PullInZshNamedDirectories()
    if (exists("$HOME"))
        let l:namedirs = $HOME . "/.znameddirs"
        if (filereadable(l:namedirs))
            let l:lines = readfile(l:namedirs)
            for l:a in l:lines
                let l:splitdir = split(l:a, " ")
                if (len(l:splitdir) == 2 && match(l:splitdir[0], '[^a-z0-9_A-Z]') == -1)
                    exec "let $" . l:splitdir[0] . " = '" . fnameescape(l:splitdir[1]) ."'"
                endif
            endfor
        endif
    endif
endfunction

call PullInZshNamedDirectories()
